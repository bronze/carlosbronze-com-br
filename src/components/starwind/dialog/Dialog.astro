---
import type { HTMLAttributes } from "astro/types";

type Props = HTMLAttributes<"div">;

const { class: className, ...rest } = Astro.props;
---

<div class:list={["starwind-dialog", className]} data-slot="dialog" {...rest}>
  <slot />
</div>

<script>
  // Store instances in a WeakMap to avoid memory leaks
  const dialogInstances = new WeakMap<HTMLElement, DialogHandler>();
  let dialogCounter = 0;

  class DialogHandler {
    private triggers: HTMLButtonElement[] = [];
    private dialog: HTMLDialogElement | null = null;
    private closeButtons: HTMLButtonElement[] = [];
    private backdrop: HTMLElement | null = null;
    private dialogWrapper: HTMLElement;
    private dialogId: string;
    /**
     * The duration of the animation in milliseconds. This is used to calculate the
     * duration of close animation before hiding the dialog and backdrop
     */
    private animationDuration: number;
    private parentDialog: DialogHandler | null = null;
    private nestedOpenCount: number = 0;
    private isNested: boolean = false;
    private _closeTimeout: number | null = null;
    private _isClosing: boolean = false;

    constructor(dialogWrapper: HTMLElement, dialogNumber: number) {
      this.dialogWrapper = dialogWrapper;
      this.dialog = dialogWrapper.querySelector("dialog");
      this.backdrop = dialogWrapper.querySelector(".starwind-dialog-backdrop");
      if (!this.dialog || !this.backdrop) {
        throw new Error("Dialog: dialog or backdrop not found");
      }

      // if no ID was provided for the wrapper, generate one
      if (dialogWrapper.id) {
        this.dialogId = dialogWrapper.id;
      } else {
        this.dialogId = `starwind-dialog${dialogNumber}`;
        dialogWrapper.id = this.dialogId;
      }

      // animationDuration is set with inline styles through passed prop to DialogContent
      // if no animationDuration, check data-close-duration
      const animationDurationString = this.dialog.style.animationDuration;
      if (animationDurationString.endsWith("ms")) {
        this.animationDuration = parseFloat(animationDurationString);
      } else if (animationDurationString.endsWith("s")) {
        // using something like @playform/compress might optimize to use "s" instead of "ms"
        this.animationDuration = parseFloat(animationDurationString) * 1000;
      } else {
        this.animationDuration = this.dialog.dataset.closeDuration
          ? parseFloat(this.dialog.dataset.closeDuration)
          : 200;
      }

      // Find internal triggers and handle them
      const internalTriggers = dialogWrapper.querySelectorAll(".starwind-dialog-trigger");
      internalTriggers.forEach((triggerElement) => {
        const tempTrigger = triggerElement as HTMLElement;
        let trigger: HTMLButtonElement;

        if (tempTrigger?.hasAttribute("data-as-child")) {
          trigger = tempTrigger.firstElementChild as HTMLButtonElement;
        } else {
          trigger = tempTrigger as HTMLButtonElement;
        }

        if (trigger) {
          this.triggers.push(trigger);
        }
      });

      // Find external triggers that target this dialog
      this.findExternalTriggers();

      // if closeButtons are set with asChild, swap the wrapper with its first child
      const tempCloseButtons = dialogWrapper.querySelectorAll(
        ".starwind-dialog-close",
      ) as NodeListOf<HTMLElement>;
      tempCloseButtons.forEach((button: HTMLElement) => {
        if (button.hasAttribute("data-as-child")) {
          const childElement = button.firstElementChild;
          if (childElement) {
            childElement.classList.add("starwind-dialog-close");
            button.parentNode?.replaceChild(childElement, button);
          }
        }
        return button;
      });

      // Convert NodeList to Array for consistency with triggers
      this.closeButtons = Array.from(
        dialogWrapper.querySelectorAll(".starwind-dialog-close"),
      ) as HTMLButtonElement[];

      // if essential elements are not there, exit
      if (!this.dialog || !this.backdrop) return;

      this.setupAccessibility(dialogNumber);
      this.setupEvents();
    }

    private setupAccessibility(dialogNumber: number): void {
      // get the first heading element in the dialog
      const firstHeading = this.dialog?.querySelector("h1, h2, h3, h4, h5, h6");
      if (firstHeading) {
        // create a unique ID for the heading
        firstHeading.id = `starwind-dialog${dialogNumber}-heading`;
        // set the aria-labelledby attribute to the first heading element
        this.dialog?.setAttribute("aria-labelledby", firstHeading.id);
      }
    }

    /**
     * Find all external triggers that target this dialog
     */
    private findExternalTriggers(): void {
      const externalTriggers = document.querySelectorAll(
        `.starwind-dialog-trigger[data-dialog-for="${this.dialogId}"]`,
      );

      externalTriggers.forEach((triggerElement) => {
        // Skip if this is an internal trigger we already processed
        const dialogWrapper = triggerElement.closest(".starwind-dialog");
        if (dialogWrapper && dialogWrapper.id === this.dialogId) {
          return;
        }

        let trigger: HTMLButtonElement;
        if (triggerElement.hasAttribute("data-as-child")) {
          trigger = triggerElement.firstElementChild as HTMLButtonElement;
        } else {
          trigger = triggerElement as HTMLButtonElement;
        }

        if (trigger && !this.triggers.includes(trigger)) {
          this.triggers.push(trigger);
        }
      });
    }

    private setupEvents(): void {
      if (!this.dialog) return;

      // Add programmatic open/close via custom events on the wrapper
      this.dialogWrapper.addEventListener("dialog:open", () => this.open());
      this.dialogWrapper.addEventListener("dialog:close", () => this.close());
      this.dialogWrapper.addEventListener("dialog:toggle", () => {
        if (this.dialog?.open) {
          this.close();
        } else {
          this.open();
        }
      });

      // Add click listeners to all triggers
      this.triggers.forEach((trigger) => {
        trigger.addEventListener("click", () => {
          this.open();
        });
      });

      // Add click handlers to all close buttons
      this.closeButtons?.forEach((button) => {
        button.addEventListener("click", () => {
          // Only close if this is the topmost dialog
          const openDialogs = document.querySelectorAll("dialog[open]");
          if (openDialogs.length > 0 && openDialogs[openDialogs.length - 1] === this.dialog) {
            this.close();
          }
        });
      });

      // Close on click outside
      this.dialog.addEventListener("click", (e) => {
        if (!this.dialog) return;
        const dialogDimensions = this.dialog.getBoundingClientRect();
        const clickedInDialog =
          e.clientX >= dialogDimensions.left &&
          e.clientX <= dialogDimensions.right &&
          e.clientY >= dialogDimensions.top &&
          e.clientY <= dialogDimensions.bottom;

        if (!clickedInDialog) {
          // Only close if this is the topmost dialog
          const openDialogs = document.querySelectorAll("dialog[open]");
          if (openDialogs.length > 0 && openDialogs[openDialogs.length - 1] === this.dialog) {
            this.close();
          }
        }
      });

      // Handle escape key
      this.dialog.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          // prevent default dialog closing behavior so we can add closing animation
          e.preventDefault();
          // Only close if this is the topmost dialog
          const openDialogs = document.querySelectorAll("dialog[open]");
          if (openDialogs.length > 0 && openDialogs[openDialogs.length - 1] === this.dialog) {
            this.close();
          }
        }
      });

      // Intercept form submissions to handle dialog close
      const forms = this.dialog.querySelectorAll("form");
      forms.forEach((form) => {
        form.addEventListener("submit", (e) => {
          /**
           * Default form.method = "dialog" submissions cause the dialog to close
           * Default form.method = "post" submissions do not close the dialog
           * Here we intercept the form submission and manage the dialog closing if method = "dialog"
           * so we can add closing animation
           * Normal form event listeners for "submit" will still get the form data
           */
          if (form.method === "dialog") {
            e.preventDefault();
            // Only close if this is the topmost dialog
            const openDialogs = document.querySelectorAll("dialog[open]");
            if (openDialogs.length > 0 && openDialogs[openDialogs.length - 1] === this.dialog) {
              this.close();
            }
          }
        });
      });
    }

    private open(): void {
      if (!this.dialog || !this.backdrop) return;
      // Return early if already open
      if (this.dialog.open && !this._isClosing) return;

      // Cancel any pending close
      if (this._closeTimeout !== null) {
        clearTimeout(this._closeTimeout);
        this._closeTimeout = null;
      }
      this._isClosing = false;

      // Reset nested count when opening (in case it wasn't properly reset)
      this.nestedOpenCount = 0;
      this.updateNestedState();

      this.dialog.showModal();
      document.body.classList.add("overflow-hidden");

      // For nested dialogs, hide the backdrop and notify parent
      if (this.isNested && this.parentDialog) {
        this.backdrop.classList.add("hidden");
        this.parentDialog.onNestedDialogOpen();
      } else {
        this.backdrop.classList.remove("hidden");
        this.backdrop.dataset.state = "open";
      }

      this.dialog.dataset.state = "open";
    }

    private close(): void {
      if (!this.dialog || !this.backdrop) return;
      // Return early if already closed or closing
      if (!this.dialog.open || this._isClosing) return;

      // Clear any existing close timeout
      if (this._closeTimeout !== null) {
        clearTimeout(this._closeTimeout);
        this._closeTimeout = null;
      }

      this._isClosing = true;
      this.dialog.dataset.state = "closed";

      // Notify parent dialog that nested dialog is closing
      if (this.isNested && this.parentDialog) {
        this.parentDialog.onNestedDialogClose();
      } else {
        this.backdrop.dataset.state = "closed";
      }

      // Wait for animation to finish before hiding backdrop
      this._closeTimeout = window.setTimeout(() => {
        if (!this.isNested) {
          this.backdrop?.classList.add("hidden");
        }
        this.dialog?.close();
        this._isClosing = false;
        this._closeTimeout = null;
        const stillOpen = document.querySelectorAll("dialog[open]").length;
        if (stillOpen === 0) {
          document.body.classList.remove("overflow-hidden");
        }
      }, this.animationDuration);
    }

    /**
     * Called by child dialogs when they open
     */
    public onNestedDialogOpen(): void {
      this.nestedOpenCount++;
      this.updateNestedState();
      // Propagate up the chain to grandparent dialogs
      if (this.parentDialog) {
        this.parentDialog.onNestedDialogOpen();
      }
    }

    /**
     * Called by child dialogs when they close
     */
    public onNestedDialogClose(): void {
      this.nestedOpenCount = Math.max(0, this.nestedOpenCount - 1);
      this.updateNestedState();
      // Propagate up the chain to grandparent dialogs
      if (this.parentDialog) {
        this.parentDialog.onNestedDialogClose();
      }
    }

    /**
     * Updates the nested dialog state attributes
     */
    private updateNestedState(): void {
      if (!this.dialog) return;

      if (this.nestedOpenCount > 0) {
        this.dialog.setAttribute("data-nested-dialog-open", "");
        this.dialog.style.setProperty("--nested-dialogs", String(this.nestedOpenCount));
      } else {
        this.dialog.removeAttribute("data-nested-dialog-open");
        this.dialog.style.removeProperty("--nested-dialogs");
      }
    }

    /**
     * Links this dialog to its parent dialog (called after all dialogs are initialized)
     */
    public linkParentDialog(): void {
      const parentDialogWrapper = this.dialogWrapper.parentElement?.closest(".starwind-dialog");
      if (parentDialogWrapper) {
        this.isNested = true;
        const parentInstance = dialogInstances.get(parentDialogWrapper as HTMLElement);
        if (parentInstance) {
          this.parentDialog = parentInstance;
        }
      }
    }
  }

  // Initialize all dialogs
  const setupDialogs = () => {
    // First pass: create all dialog instances
    document.querySelectorAll(".starwind-dialog").forEach((dialogWrapper) => {
      const wrapper = dialogWrapper as HTMLElement;
      if (!dialogInstances.has(wrapper)) {
        dialogInstances.set(wrapper, new DialogHandler(wrapper, dialogCounter++));
      }
    });

    // Second pass: link parent dialogs (now that all instances exist)
    document.querySelectorAll(".starwind-dialog").forEach((dialogWrapper) => {
      const wrapper = dialogWrapper as HTMLElement;
      const instance = dialogInstances.get(wrapper);
      if (instance) {
        instance.linkParentDialog();
      }
    });
  };

  setupDialogs();
  document.addEventListener("astro:after-swap", setupDialogs);
  document.addEventListener("starwind:init", setupDialogs);
</script>

<style>
  .overflow-hidden {
    overflow: hidden;
  }
</style>
